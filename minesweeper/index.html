<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Minesweeper</title>
  <style>
    :root {
      --cell-size: 30px;
      --mine-color: red;
      --flag-color: orange;
      --border-color: #888;
    }
    body {
      font-family: sans-serif;
      text-align: center;
      background: #f0f0f0;
    }
    h1 {
      margin: 1rem 0;
    }
    #controls {
      margin-bottom: 1rem;
    }
    #board {
      display: inline-block;
      border: 2px solid #444;
      background: #ccc;
    }
    .row {
      display: flex;
    }
    .cell {
      width: var(--cell-size);
      height: var(--cell-size);
      line-height: var(--cell-size);
      text-align: center;
      border-right: 1px solid var(--border-color);
      border-bottom: 1px solid var(--border-color);
      background: #e0e0e0;
      box-shadow: inset 1px 1px 0 #fff, inset -1px -1px 0 #aaa;
      cursor: pointer;
      user-select: none;
    }
    .cell:first-child {
      border-left: 1px solid var(--border-color);
    }
    .row:first-child .cell {
      border-top: 1px solid var(--border-color);
    }
    .cell.revealed {
      background: #ddd;
      box-shadow: none;
      cursor: default;
    }
    .cell.mine { color: var(--mine-color); }
    .cell.flag { color: var(--flag-color); }
    #status {
      margin: 1rem;
      font-size: 1.2em;
    }
    #start {
      padding: 0.5em 2em;
      font-size: 1.2em;
      cursor: pointer;
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <h1>Minesweeper</h1>
  <div id="controls">
    <label>Rows: <input type="number" id="rows" value="9" min="5" max="30" /></label>
    <label>Cols: <input type="number" id="cols" value="9" min="5" max="30" /></label>
    <label>Mines: <input type="number" id="mines" value="10" min="1" /></label>
    <button id="start">Start</button>
  </div>
  <div id="status"></div>
  <div id="board"></div>

  <script>
    const board = document.getElementById("board");
    const status = document.getElementById("status");
    const startBtn = document.getElementById("start");
    let rows, cols, mineCount, cells, firstClick;

    startBtn.onclick = () => init();

    function init() {
      rows = parseInt(document.getElementById("rows").value);
      cols = parseInt(document.getElementById("cols").value);
      mineCount = parseInt(document.getElementById("mines").value);
      cells = [];
      firstClick = true;
      status.textContent = '';
      board.innerHTML = "";

      for (let r = 0; r < rows; r++) {
        const rowDiv = document.createElement("div");
        rowDiv.className = "row";
        const row = [];
        for (let c = 0; c < cols; c++) {
          const cell = document.createElement("div");
          cell.className = "cell";
          cell.dataset.row = r;
          cell.dataset.col = c;
          cell.oncontextmenu = e => {
            e.preventDefault();
            toggleFlag(cell);
          };
          cell.onclick = () => handleClick(r, c);
          row.push({ el: cell, revealed: false, flagged: false, mine: false, number: 0 });
          rowDiv.appendChild(cell);
        }
        board.appendChild(rowDiv);
        cells.push(row);
      }
    }

    function placeMines(excludeR, excludeC) {
      let placed = 0;
      while (placed < mineCount) {
        let r = Math.floor(Math.random() * rows);
        let c = Math.floor(Math.random() * cols);
        if ((r === excludeR && c === excludeC) || cells[r][c].mine) continue;
        cells[r][c].mine = true;
        placed++;
      }
      // Calculate numbers
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          if (!cells[r][c].mine) {
            cells[r][c].number = getNeighbors(r, c).filter(n => n.mine).length;
          }
        }
      }
    }

    function handleClick(r, c) {
      if (firstClick) {
        placeMines(r, c);
        firstClick = false;
      }
      reveal(r, c);
    }

    function reveal(r, c) {
      const cell = cells[r][c];
      if (cell.revealed || cell.flagged) return;
      cell.revealed = true;
      cell.el.classList.add("revealed");
      if (cell.mine) {
        cell.el.textContent = "ðŸ’£";
        cell.el.classList.add("mine");
        status.textContent = "Game Over!";
        revealAll();
        return;
      }
      if (cell.number > 0) {
        cell.el.textContent = cell.number;
      } else {
        getNeighbors(r, c).forEach(n => reveal(n.r, n.c));
      }
      checkWin();
    }

    function toggleFlag(cellEl) {
      const r = parseInt(cellEl.dataset.row);
      const c = parseInt(cellEl.dataset.col);
      const cell = cells[r][c];
      if (cell.revealed) return;
      cell.flagged = !cell.flagged;
      cell.el.textContent = cell.flagged ? "ðŸš©" : "";
      cell.el.classList.toggle("flag");
    }

    function getNeighbors(r, c) {
      const neighbors = [];
      for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
          if (dr === 0 && dc === 0) continue;
          const nr = r + dr, nc = c + dc;
          if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
            neighbors.push({ ...cells[nr][nc], r: nr, c: nc });
          }
        }
      }
      return neighbors;
    }

    function revealAll() {
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const cell = cells[r][c];
          if (!cell.revealed) {
            cell.revealed = true;
            cell.el.classList.add("revealed");
            if (cell.mine) cell.el.textContent = "ðŸ’£";
            else if (cell.number > 0) cell.el.textContent = cell.number;
          }
        }
      }
    }

    function checkWin() {
      let unrevealed = 0;
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          if (!cells[r][c].revealed) unrevealed++;
        }
      }
      if (unrevealed === mineCount) {
        status.textContent = "ðŸŽ‰ You Win!";
        revealAll();
      }
    }
  </script>
</body>
</html>
